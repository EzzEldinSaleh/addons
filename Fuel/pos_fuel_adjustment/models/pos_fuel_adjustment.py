from odoo import api, fields, models,_from odoo.exceptions import UserError,ValidationErrorfrom odoo.tools import float_compare, float_is_zeroclass PosConfigInherit(models.Model):    _inherit = 'pos.config'    location_ids = fields.Many2many(comodel_name="stock.location", relation="r", column1="e", column2="t", string="Locations Adjustment", )    def open_session_cb(self, check_coa=True):        """ new session button        create one if none exist        access cash control interface if enabled or start a session        """        self.ensure_one()        if not self.current_session_id:            self._check_company_journal()            self._check_company_invoice_journal()            self._check_company_payment()            self._check_currencies()            self._check_profit_loss_cash_journal()            self._check_payment_method_ids()            self._check_payment_method_receivable_accounts()            self.env['pos.session'].create({                'user_id': self.env.uid,                'config_id': self.id            })        vals = {            'name': "Tank Reading - '%s'" % (self.current_session_id.name),            'created_id': self.current_session_id.user_id.id,            'pos_session_id': self.current_session_id.id,            'product_ids': self.env['product.product'].search([('is_fuel','=',True),('pos_config_id','=',self.id)]).ids,            'location_ids': self.location_ids.ids,        }        create_stock_inventory=self.env['stock.inventory'].create(vals)        create_stock_inventory.action_start()        return self.open_ui()class PosSessionInherit(models.Model):    _inherit = 'pos.session'    def open_adjustment(self):        return {            'name': _('Adjustments'),            'type': 'ir.actions.act_window',            'domain': [('pos_session_id', '=',self.id)],            'view_mode': 'tree,form',            'res_model': 'stock.inventory',            'target': 'current'        }    def action_pos_session_closing_control(self):        self._check_pos_session_balance()        for session in self:            adjustments=self.env['stock.inventory'].search([('pos_session_id', '=', self.id)])            if adjustments:                if adjustments.state == 'done':                    if any(order.state == 'draft' for order in session.order_ids):                        raise UserError(_("You cannot close the POS when orders are still in draft"))                    if session.state == 'closed':                        raise UserError(_('This session is already closed.'))                    session.write({'state': 'closing_control', 'stop_at': fields.Datetime.now()})                    if not session.config_id.cash_control:                        session.action_pos_session_close()                else:                    raise ValidationError("You cannot close the session before being adjustment validated")            else:                if any(order.state == 'draft' for order in session.order_ids):                    raise UserError(_("You cannot close the POS when orders are still in draft"))                if session.state == 'closed':                    raise UserError(_('This session is already closed.'))                session.write({'state': 'closing_control', 'stop_at': fields.Datetime.now()})                if not session.config_id.cash_control:                    session.action_pos_session_close()class StockInventoryInherit(models.Model):    _inherit = 'stock.inventory'    pos_session_id = fields.Many2one(comodel_name='pos.session', required=False, )    created_id = fields.Many2one(comodel_name='res.users',string="Created By", required=False, )    def action_validate(self):        if not self.exists():            return        stockinvontorylines=self.env['stock.inventory.line'].search([('inventory_id','=',self.id),('is_refreshed','=',True)])        if self.line_ids.ids:            if self.line_ids.ids == stockinvontorylines.ids:                self.ensure_one()                if not self.user_has_groups('stock.group_stock_manager'):                    raise UserError(_("Only a stock manager can validate an inventory adjustment."))                if self.state != 'confirm':                    raise UserError(_(                        "You can't validate the inventory '%s', maybe this inventory "                        "has been already validated or isn't ready.", self.name))                inventory_lines = self.line_ids.filtered(lambda l: l.product_id.tracking in ['lot', 'serial'] and not l.prod_lot_id and l.theoretical_qty != l.product_qty)                lines = self.line_ids.filtered(lambda l: float_compare(l.product_qty, 1, precision_rounding=l.product_uom_id.rounding) > 0 and l.product_id.tracking == 'serial' and l.prod_lot_id)                if inventory_lines and not lines:                    wiz_lines = [(0, 0, {'product_id': product.id, 'tracking': product.tracking}) for product in inventory_lines.mapped('product_id')]                    wiz = self.env['stock.track.confirmation'].create({'inventory_id': self.id, 'tracking_line_ids': wiz_lines})                    return {                        'name': _('Tracked Products in Inventory Adjustment'),                        'type': 'ir.actions.act_window',                        'view_mode': 'form',                        'views': [(False, 'form')],                        'res_model': 'stock.track.confirmation',                        'target': 'new',                        'res_id': wiz.id,                    }                self._action_done()                self.line_ids._check_company()                self._check_company()            else:                raise ValidationError('You have to Refresh all QTYs before Validate adjustment')        else:            self.ensure_one()            if not self.user_has_groups('stock.group_stock_manager'):                raise UserError(_("Only a stock manager can validate an inventory adjustment."))            if self.state != 'confirm':                raise UserError(_(                    "You can't validate the inventory '%s', maybe this inventory "                    "has been already validated or isn't ready.", self.name))            inventory_lines = self.line_ids.filtered(lambda l: l.product_id.tracking in ['lot',                                                                                         'serial'] and not l.prod_lot_id and l.theoretical_qty != l.product_qty)            lines = self.line_ids.filtered(lambda l: float_compare(l.product_qty, 1,                                                                   precision_rounding=l.product_uom_id.rounding) > 0 and l.product_id.tracking == 'serial' and l.prod_lot_id)            if inventory_lines and not lines:                wiz_lines = [(0, 0, {'product_id': product.id, 'tracking': product.tracking}) for product in                             inventory_lines.mapped('product_id')]                wiz = self.env['stock.track.confirmation'].create(                    {'inventory_id': self.id, 'tracking_line_ids': wiz_lines})                return {                    'name': _('Tracked Products in Inventory Adjustment'),                    'type': 'ir.actions.act_window',                    'view_mode': 'form',                    'views': [(False, 'form')],                    'res_model': 'stock.track.confirmation',                    'target': 'new',                    'res_id': wiz.id,                }            self._action_done()            self.line_ids._check_company()            self._check_company()        return Trueclass ProductInherit(models.Model):    _inherit = 'product.product'    is_fuel = fields.Boolean(string="Is Fuel",  )    pos_config_id = fields.Many2one(comodel_name="pos.config", string="Selected Pos", required=False, )class StockMoveLineInherit(models.Model):    _inherit = 'stock.inventory.line'    is_refreshed = fields.Boolean()    def action_refresh_quantity_all(self):        for x in self:            x.action_refresh_quantity()    def action_refresh_quantity(self):        filtered_lines = self.filtered(lambda l: l.state != 'done')        for line in filtered_lines:            if line.outdated:                quants = self.env['stock.quant']._gather(line.product_id, line.location_id, lot_id=line.prod_lot_id,                                                         package_id=line.package_id, owner_id=line.partner_id,                                                         strict=True)                if quants.exists():                    quantity = sum(quants.mapped('quantity'))                    if line.theoretical_qty != quantity:                        line.theoretical_qty = quantity                else:                    line.theoretical_qty = 0                line.inventory_date = fields.Datetime.now()            line.is_refreshed=True